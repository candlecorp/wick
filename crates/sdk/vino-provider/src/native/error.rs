use thiserror::Error;
use tokio::sync::mpsc::error::SendError;
use vino_packet::PacketWrapper;

#[derive(Error, Debug)]
/// Vino Provider's error type.
pub enum Error {
  /// Error returned when a component can not be found.
  #[error("Component '{0}' not found on this provider")]
  ComponentNotFound(String),

  /// Send error.
  #[error(transparent)]
  IOError(#[from] std::io::Error),

  /// Error sending output to channel.
  #[error("Error sending output to channel")]
  SendError,

  /// Tried to receive from an empty channel.
  #[error("Nothing in channel to receive")]
  ChannelEmpty,

  /// Tried to send to a closed channel.
  #[error("Tried to send a message to a closed channel")]
  SendChannelClosed,

  /// Tried to receive from a closed channel.
  #[error("Tried to send a message to a closed channel")]
  ReceiveChannelClosed,

  /// Unspecified upstream error.
  #[error(transparent)]
  OtherUpstreamError(#[from] Box<dyn std::error::Error + Send + Sync>),
}

#[derive(Error, Debug)]
#[must_use]
/// The error type that components can return on failures.
pub struct NativeComponentError {
  msg: String,
}

impl std::fmt::Display for NativeComponentError {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    f.write_str(&self.msg)
  }
}

impl NativeComponentError {
  /// Constructor for [ProviderComponentError].
  pub fn new<T: AsRef<str>>(msg: T) -> Self {
    Self {
      msg: msg.as_ref().to_owned(),
    }
  }
}

impl From<&'static str> for NativeComponentError {
  fn from(e: &'static str) -> Self {
    NativeComponentError::new(e.to_owned())
  }
}

impl From<String> for NativeComponentError {
  fn from(e: String) -> Self {
    NativeComponentError::new(e)
  }
}

impl From<SendError<PacketWrapper>> for Error {
  fn from(_: SendError<PacketWrapper>) -> Self {
    Self::SendError
  }
}

impl From<Error> for NativeComponentError {
  fn from(e: Error) -> Self {
    Self::new(e.to_string())
  }
}

/// The RPC Error type.
#[derive(Error, Debug)]
pub enum RpcError {
  /// Upstream Error from [vino_entity].
  #[error(transparent)]
  EntityError(#[from] vino_entity::Error),

  /// Invalid [crate::rpc::component::ComponentKind].
  #[error("Invalid component kind {0}")]
  InvalidComponentKind(i32),

  /// Error used by providers.
  #[error("Error: {0}")]
  ProviderError(String),

  /// Error generated by a provider's components.
  #[error("Error: {0}")]
  ComponentError(String),

  /// Error sending output to channel.
  #[error("Error sending output to channel")]
  SendError,

  /// General Error.
  #[error("General error : {0}")]
  Other(String),
}

impl From<Error> for Box<RpcError> {
  fn from(e: Error) -> Self {
    Box::new(RpcError::ProviderError(e.to_string()))
  }
}

impl From<NativeComponentError> for Box<RpcError> {
  fn from(e: NativeComponentError) -> Self {
    Box::new(RpcError::ProviderError(e.to_string()))
  }
}

impl From<Box<dyn std::error::Error + Send + Sync>> for RpcError {
  fn from(e: Box<dyn std::error::Error + Send + Sync>) -> Self {
    RpcError::ProviderError(e.to_string())
  }
}

impl From<vino_entity::Error> for Box<RpcError> {
  fn from(e: vino_entity::Error) -> Self {
    Box::new(RpcError::EntityError(e))
  }
}
